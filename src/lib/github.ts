import axios from "axios";

const BASE = "https://api.github.com";

export async function fetchUserRepos(token: string) {
  const res = await axios.get(`${BASE}/user/repos`, {
    headers: { Authorization: `Bearer ${token}` },
    params: { sort: "updated", per_page: 100 }
  });
  return res.data;
}

export async function fetchRepoDetails(
  token: string,
  owner: string,
  repo: string
) {
  const [info, tree, readme, pkgJson] = await Promise.allSettled([
    axios.get(`${BASE}/repos/${owner}/${repo}`, {
      headers: { Authorization: `Bearer ${token}` }
    }),
    axios.get(`${BASE}/repos/${owner}/${repo}/git/trees/HEAD?recursive=1`, {
      headers: { Authorization: `Bearer ${token}` }
    }),
    axios.get(`${BASE}/repos/${owner}/${repo}/readme`, {
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github.raw+json"
      }
    }),
    axios.get(`${BASE}/repos/${owner}/${repo}/contents/package.json`, {
      headers: { Authorization: `Bearer ${token}` }
    })
  ]);

  const unwrap = (r: PromiseSettledResult<any>) =>
    r.status === "fulfilled" ? r.value.data : null;

  const repoInfo = unwrap(info);
  const treeData = unwrap(tree);
  const readmeData = unwrap(readme);
  const pkgFile = unwrap(pkgJson);

  let pkg: any = null;
  if (pkgFile?.content) {
    try {
      const decoded = Buffer.from(pkgFile.content, "base64").toString("utf8");
      pkg = JSON.parse(decoded);
    } catch {
      pkg = null;
    }
  }

  return {
    repoInfo,
    tree: treeData,
    readme: readmeData,
    pkgJson: pkg
  };
}

export async function createReadmePullRequest(
  token: string,
  params: { owner: string; repo: string; readmeContent: string }
) {
  const { owner, repo, readmeContent } = params;

  const client = axios.create({
    baseURL: BASE,
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: "application/vnd.github+json"
    }
  });

  // 1. repo info
  const repoRes = await client.get(`/repos/${owner}/${repo}`);
  const baseBranch = repoRes.data.default_branch as string;

  // 2. base branch ref
  const refRes = await client.get(
    `/repos/${owner}/${repo}/git/ref/heads/${baseBranch}`
  );
  const baseCommitSha = refRes.data.object.sha as string;

  // 3. fetch commit to get tree SHA
  const commitRes = await client.get(
    `/repos/${owner}/${repo}/git/commits/${baseCommitSha}`
  );
  const baseTreeSha = commitRes.data.tree.sha as string;

  // 4. new branch
  const branchName = `repocraft/readme-${Date.now()}`;
  await client.post(`/repos/${owner}/${repo}/git/refs`, {
    ref: `refs/heads/${branchName}`,
    sha: baseCommitSha
  });

  // 5. blob for README
  const blobRes = await client.post(`/repos/${owner}/${repo}/git/blobs`, {
    content: readmeContent,
    encoding: "utf-8"
  });
  const blobSha = blobRes.data.sha as string;

  // 6. new tree with README.md
  const treeRes = await client.post(`/repos/${owner}/${repo}/git/trees`, {
    base_tree: baseTreeSha,
    tree: [
      {
        path: "README.md",
        mode: "100644",
        type: "blob",
        sha: blobSha
      }
    ]
  });
  const newTreeSha = treeRes.data.sha as string;

  // 7. commit on new branch
  const commitNewRes = await client.post(`/repos/${owner}/${repo}/git/commits`, {
    message: "chore: update README via RepoCraft",
    tree: newTreeSha,
    parents: [baseCommitSha]
  });
  const newCommitSha = commitNewRes.data.sha as string;

  // 8. move new branch to new commit
  await client.patch(`/repos/${owner}/${repo}/git/refs/heads/${branchName}`, {
    sha: newCommitSha
  });

  // 9. create PR
  const prRes = await client.post(`/repos/${owner}/${repo}/pulls`, {
    title: "Update README via RepoCraft",
    head: branchName,
    base: baseBranch,
    body:
      "This README was generated by RepoCraft. Please review and merge if it looks good."
  });

  return prRes.data; // includes html_url
}
